---
layout: post
title:  一个Linux进程的虚拟存储器分布
date:   2014-11-08 
categories:
- coding
tags:
- 内存分段
---


### 进程虚拟存储器的分类

一个Linux进程的虚拟存储器可以分为以下5部分：

![virtual_memory_of_linux_op](http://7wy3wu.com1.z0.glb.clouddn.com/virtual_memory_of_linux_op.png)

* 栈(stack)：栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。
从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。

* 堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。
当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；
当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。

* BSS段（bss segment）：BSS段通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称，BSS段属于静态内存分配。

* 数据段（data segment）：数据段通常是指用来存放程序中已初始化的全局变量（global）和静态变量（static）的一块内存区域。数据段属于静态内存分配。

* 代码段（code segment/text segment）：代码段通常是指用来存放程序执行代码的一块内存区域。
这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。
在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。
代码段是存放了程序代码的数据，假如机器中有数个进程运行相同的一个程序，那么它们就可以使用同一个代码段。


### 例子程序1

以下这段代码说明各类型变量的存储位置：

<pre><code>
int a = 0; //全局初始化区 
char *p1;  //全局未初始化区 

int main() 
{ 
    int b; //栈 
    char s[] = "abc"; //栈 
    char *p2; //栈 
    char *p3 = "123456"; //123456在常量区，p3在栈上。 
    static int c = 0；    //全局（静态）初始化区 
    p1 = (char *)malloc(10); 
    p2 = (char *)malloc(20); //分配得来得10和20字节的区域就在堆区。 
    strcpy(p1, "123456");   //123456放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。 
    return 0;
} 
</code></pre>


### 例子程序2

<p>以下两段代码说明bss和data分段的区别：</p>
<p>代码A:</p>
<pre><code>
int ar[30000];
void main()
{
    ......
}
</code></pre>

<p>代码B:</p>
<pre><code>
int ar[300000] =  {1, 2, 3, 4, 5, 6 };
void main()
{
    ......
}
</code></pre>

发现程序B编译之后所得的.exe文件比程序A的要大得多。为什么？<br />
区别很明显，一个位于.bss段，而另一个位于.data段，两者的区别在于：

* 全局的未初始化变量存在于.bss段中，具体体现为一个占位符；全局的已初始化变量存于.data段中；
* .bss不占用.exe文件空间，其内容由操作系统初始化（清零）；
* 而.data需要占用.exe文件空间，其内容由程序初始化。


> * 参考了[这里](http://my.oschina.net/pollybl1255/blog/140323)和[这里](http://blog.csdn.net/canbus/article/details/8660065)
> * 文中的插图来自“深入理解计算机系统”，第10章“虚拟存储器”
> * 网上有文章针对C++增加了一类“自由存储区”，其实和堆是一类，实在没必要单列
